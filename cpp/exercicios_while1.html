<!DOCTYPE html>
<html lang="pt-br">
<head>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    
    <link rel="stylesheet" href="../estilo.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Inter:wght@400;600;700;800&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <title>Guia C++: Exerc√≠cios de Fun√ß√µes e La√ßos</title>
    
    <!-- Biblioteca de √°udio Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

</head>

<body data-barba="wrapper">

        <button id="theme-toggle" aria-label="Alternar tema" title="Alternar tema">
        <span id="theme-icon">üåô</span>
        </button>

    <div data-barba="container" data-barba-namespace="Cpp-While-Exercicios" namespace="default-view">

<header>

    <button class="settings-btn" aria-label="Configura√ß√µes">
        <i class="fas fa-bars"></i>
    </button>

    <!-- T√≠tulo atualizado para o novo foco -->
    <h1>Exerc√≠cios de L√≥gica com C++ üß†</h1>
    <p>Implementando fun√ß√µes cl√°ssicas de matem√°tica e sequ√™ncias com la√ßos de repeti√ß√£o.</p>

    <!-- A navega√ß√£o foi mantida para consist√™ncia -->
    <nav>
        <p><a href="../index.html" class="nav-link">Inic√≠o üè°</a></p>
        <p><a href="../Hubs/ArquiteturaComp-Hub.html" class="nav-link"> Arquitetura ‚öôÔ∏è</a></p>
        <p><a href="../Hubs/Matematica-Hub.html" class="nav-link">Matem√°tica ‚úñÔ∏è</a></p>
        <p><a href="../Hubs/Cpp-Hub.html" class="nav-link">C++ üîß</a></p>
        <p><a href="../Hubs/InfoBasica-Hub.html" class="nav-link">Info B√°sica üñ•Ô∏è</a></p>
        <p><a href="../Hubs/DesignWeb-Hub.html" class="nav-link">Design Web üåê</a></p>
        <p><a href="../Hubs/Jogos-Hub.html" class="nav-link">Jogos üïπÔ∏è</a></p>
    </nav>
</header>

<main>

<div id="xml-intro">

    <section id="intro">
        <h2 class="subtitle">üéØ Resolvendo Problemas com Fun√ß√µes e La√ßos</h2>
        <p>A combina√ß√£o de fun√ß√µes para modularizar o c√≥digo e la√ßos de repeti√ß√£o para executar tarefas repetitivas √© a base da programa√ß√£o estruturada. Abaixo, voc√™ encontrar√° uma s√©rie de exerc√≠cios cl√°ssicos resolvidos em C++, demonstrando como implementar algoritmos matem√°ticos e sequenciais do zero.</p>
        <p>Cada exerc√≠cio apresenta a cria√ß√£o de uma ou mais fun√ß√µes espec√≠ficas e um programa principal (<code>main</code>) para testar sua funcionalidade, como solicitado.</p>
    </section>

    <section id="exercicios-propostos">
        <h2 class="subtitle">‚úèÔ∏è Exerc√≠cios Resolvidos</h2>

        <!-- Exerc√≠cio 1: Floor e Ceil -->
        <div class="exercise">
            <h4>Exerc√≠cio 1: Fun√ß√µes Floor e Ceil</h4>
            <p><strong>Problema:</strong> Supondo a inexist√™ncia da biblioteca <code>math.h</code>, implemente fun√ß√µes para calcular o piso (floor) e o teto (ceil) de um n√∫mero real. Crie um programa principal para test√°-las.</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include &lt;iostream&gt;

// Fun√ß√£o que calcula o piso de um n√∫mero
int meu_floor(double num) {
    int parte_inteira = (int)num;
    // Se o n√∫mero for negativo e tiver parte fracion√°ria, o piso √© a parte inteira - 1.
    // Ex: floor(-3.7) √© -4. (int)-3.7 √© -3.
    if (num < 0 && num != parte_inteira) {
        return parte_inteira - 1;
    }
    return parte_inteira;
}

// Fun√ß√£o que calcula o teto de um n√∫mero
int meu_ceil(double num) {
    int parte_inteira = (int)num;
    // Se o n√∫mero for positivo e tiver parte fracion√°ria, o teto √© a parte inteira + 1.
    // Ex: ceil(3.7) √© 4. (int)3.7 √© 3.
    if (num > 0 && num != parte_inteira) {
        return parte_inteira + 1;
    }
    return parte_inteira;
}

int main() {
    using namespace std;
    double teste1 = 5.8;
    double teste2 = -4.2;
    double teste3 = 7.0;

    cout << "Testando a funcao 'meu_floor':\n";
    cout << "O piso de " << teste1 << " e: " << meu_floor(teste1) << "\n";   // Esperado: 5
    cout << "O piso de " << teste2 << " e: " << meu_floor(teste2) << "\n";   // Esperado: -5
    cout << "O piso de " << teste3 << " e: " << meu_floor(teste3) << "\n\n"; // Esperado: 7

    cout << "Testando a funcao 'meu_ceil':\n";
    cout << "O teto de " << teste1 << " e: " << meu_ceil(teste1) << "\n";   // Esperado: 6
    cout << "O teto de " << teste2 << " e: " << meu_ceil(teste2) << "\n";   // Esperado: -4
    cout << "O teto de " << teste3 << " e: " << meu_ceil(teste3) << "\n";   // Esperado: 7
    
    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o da Resposta:</strong> A convers√£o de um <code>double</code> para <code>int</code> em C++ trunca a parte decimal.
            Para o <strong>piso (floor)</strong>, este comportamento j√° √© correto para n√∫meros positivos. Para negativos, se o n√∫mero n√£o for inteiro (ex: -4.2), o piso real √© uma unidade menor que a parte inteira truncada (-5).
            Para o <strong>teto (ceil)</strong>, o oposto acontece: para n√∫meros positivos com decimais (ex: 5.8), o teto √© uma unidade maior que a parte inteira (6). Para negativos, a parte inteira truncada j√° √© o teto (o teto de -4.2 √© -4).</p>
        </div>

        <!-- Exerc√≠cio 2: Pot√™ncia -->
        <div class="exercise">
            <h4>Exerc√≠cio 2: Fun√ß√£o de Pot√™ncia</h4>
            <p><strong>Problema:</strong> Implemente uma fun√ß√£o para calcular a pot√™ncia entre dois n√∫meros inteiros quaisquer (base e expoente positivos ou negativos). Teste os casos 2¬≥, 2‚Åª¬≥, (-3)¬≤ e (-3)‚Åª¬≤.</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include &lt;iostream&gt;

// Fun√ß√£o que calcula a pot√™ncia, lidando com expoentes negativos
double potencia(int base, int expoente) {
    double resultado = 1.0;
    
    if (expoente == 0) {
        return 1.0;
    }
    
    int exp_positivo = expoente > 0 ? expoente : -expoente;
    int contador = 0;

    while (contador < exp_positivo) {
        resultado *= base;
        contador++;
    }

    if (expoente < 0) {
        return 1.0 / resultado;
    }

    return resultado;
}

int main() {
    using namespace std;
    cout << "Testando a funcao 'potencia':\n";
    cout << "2^3 = " << potencia(2, 3) << "\n";         // Esperado: 8
    cout << "2^-3 = " << potencia(2, -3) << "\n";       // Esperado: 0.125
    cout << "-3^2 = " << potencia(-3, 2) << "\n";       // Esperado: 9
    cout << "-3^-2 = " << potencia(-3, -2) << "\n";     // Esperado: 0.111...

    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o da Resposta:</strong> A fun√ß√£o primeiro calcula a pot√™ncia para o valor absoluto do expoente usando um la√ßo <code>while</code>. Se o expoente original for 0, retorna 1. Se for positivo, o resultado do la√ßo √© retornado diretamente. Se o expoente for negativo, o resultado final √© <code>1.0</code> dividido pelo valor encontrado, conforme a propriedade matem√°tica de que x‚Åª‚Åø = 1/x‚Åø. O tipo de retorno √© <code>double</code> para lidar com os resultados fracion√°rios dos expoentes negativos.</p>
        </div>

        <!-- Exerc√≠cio 3: N√∫mero Primo -->
        <div class="exercise">
            <h4>Exerc√≠cio 3: Fun√ß√£o de N√∫mero Primo</h4>
            <p><strong>Problema:</strong> Escreva uma fun√ß√£o que retorne verdadeiro ou falso para o fato de um n√∫mero ser primo. Crie um programa principal para test√°-la.</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include &lt;iostream&gt;

// Retorna true se o n√∫mero for primo, false caso contr√°rio
bool ehPrimo(int numero) {
    if (numero <= 1) {
        return false; // 0, 1 e negativos n√£o s√£o primos
    }
    
    int divisor = 2;
    // S√≥ precisamos testar at√© a metade do n√∫mero.
    while (divisor <= numero / 2) {
        if (numero % divisor == 0) {
            return false; // Encontrou um divisor, n√£o √© primo
        }
        divisor++;
    }
    
    return true; // N√£o encontrou divisores, √© primo
}

int main() {
    using namespace std;
    cout << "Testando a funcao 'ehPrimo':\n";
    cout << "O numero 29 e primo? " << (ehPrimo(29) ? "Sim" : "Nao") << "\n";
    cout << "O numero 15 e primo? " << (ehPrimo(15) ? "Sim" : "Nao") << "\n";
    cout << "O numero 2 e primo? " << (ehPrimo(2) ? "Sim" : "Nao") << "\n";
    cout << "O numero 1 e primo? " << (ehPrimo(1) ? "Sim" : "Nao") << "\n";

    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o da Resposta:</strong> A fun√ß√£o <code>ehPrimo</code> primeiro trata dos casos base: n√∫meros menores ou iguais a 1 n√£o s√£o primos. Em seguida, um la√ßo <code>while</code> testa todos os poss√≠veis divisores de 2 at√© a metade do n√∫mero (uma otimiza√ß√£o comum). Se em algum momento o resto da divis√£o <code>numero % divisor</code> for 0, significa que um divisor foi encontrado, e a fun√ß√£o retorna <code>false</code> imediatamente. Se o la√ßo terminar sem encontrar nenhum divisor, o n√∫mero √© primo e a fun√ß√£o retorna <code>true</code>.</p>
        </div>

        <!-- Exerc√≠cio 4: Fatorial -->
        <div class="exercise">
            <h4>Exerc√≠cio 4: Fun√ß√£o Fatorial</h4>
            <p><strong>Problema:</strong> Implemente uma fun√ß√£o para calcular o fatorial de um n√∫mero inteiro n√£o-negativo. Lembre-se que 0! = 1. Crie um programa principal para test√°-la.</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include &lt;iostream&gt;

// Calcula o fatorial de um n√∫mero n√£o-negativo
unsigned long long fatorial(int n) {
    if (n < 0) {
        // Fatorial de n√∫mero negativo √© indefinido. Retornamos 0 como erro.
        return 0; 
    }
    if (n == 0) {
        return 1; // Caso base: 0! = 1
    }

    unsigned long long resultado = 1;
    int contador = n;

    while (contador > 1) {
        resultado *= contador;
        contador--;
    }

    return resultado;
}

int main() {
    using namespace std;
    cout << "Testando a funcao 'fatorial':\n";
    cout << "Fatorial de 5 (!5) = " << fatorial(5) << "\n";   // Esperado: 120
    cout << "Fatorial de 0 (!0) = " << fatorial(0) << "\n";   // Esperado: 1
    cout << "Fatorial de 10 (!10) = " << fatorial(10) << "\n"; // Esperado: 3628800

    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o da Resposta:</strong> A fun√ß√£o primeiro lida com casos especiais: retorna 0 (indicando erro) para n√∫meros negativos e retorna 1 se o n√∫mero for 0. Para n√∫meros positivos, um la√ßo <code>while</code> √© iniciado. A vari√°vel <code>resultado</code> √© multiplicada pelo <code>contador</code> (que come√ßa em <code>n</code>), e o contador √© decrementado a cada itera√ß√£o, at√© chegar a 1. O tipo de retorno <code>unsigned long long</code> √© usado para acomodar os valores grandes que os fatoriais podem atingir rapidamente.</p>
        </div>
        
        <!-- Exerc√≠cio 5: Fibonacci -->
        <div class="exercise">
            <h4>Exerc√≠cio 5: Sequ√™ncia de Fibonacci</h4>
            <p><strong>Problema:</strong> A sequ√™ncia de Fibonacci come√ßa com 0 e 1, e cada termo subsequente √© a soma dos dois anteriores (0, 1, 1, 2, 3, 5, ...). Implemente uma fun√ß√£o para retornar o n-√©simo termo da sequ√™ncia.</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include &lt;iostream&gt;

// Retorna o n-√©simo termo da sequ√™ncia de Fibonacci
int fibonacci(int n) {
    if (n <= 0) return 0; // Termo 0 ou negativo √© 0
    if (n == 1) return 1; // Termo 1 √© 1

    int anterior = 0;
    int atual = 1;
    int contador = 2; // J√° calculamos os dois primeiros termos

    while (contador <= n) {
        int proximo = anterior + atual;
        anterior = atual;
        atual = proximo;
        contador++;
    }

    return atual;
}

int main() {
    using namespace std;
    cout << "Testando a funcao 'fibonacci':\n";
    cout << "O 5¬∫ termo de Fibonacci e: " << fibonacci(5) << "\n";   // Esperado: 5
    cout << "O 8¬∫ termo de Fibonacci e: " << fibonacci(8) << "\n";   // Esperado: 21
    cout << "O 1¬∫ termo de Fibonacci e: " << fibonacci(1) << "\n";   // Esperado: 1

    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o da Resposta:</strong> A fun√ß√£o trata os casos base <code>n=0</code> e <code>n=1</code>. Para <code>n > 1</code>, inicializamos <code>anterior = 0</code> e <code>atual = 1</code>. O la√ßo <code>while</code> roda de 2 at√© <code>n</code>. Em cada itera√ß√£o, calculamos o pr√≥ximo termo somando os dois anteriores. Em seguida, atualizamos as vari√°veis: o <code>atual</code> vira o <code>anterior</code>, e o <code>proximo</code> calculado vira o novo <code>atual</code>. O la√ßo efetivamente "caminha" pela sequ√™ncia at√© atingir a posi√ß√£o <code>n</code>, retornando o valor contido em <code>atual</code>.</p>
        </div>
    </section>

</div>

</main>

</div>

<footer>
    <p class="copyright"> ¬©Ô∏è 2025 - Lucas Willian</p>
</footer>

    <!-- Scripts originais mantidos no final para funcionalidade da p√°gina -->
    <div id="player-wrapper" class="is-hidden">
        <button id="toggle-player-btn" aria-label="Controlar Player">
            <i class="fas fa-chevron-down"></i>
        </button>
        <iframe 
            id="meu-player-de-musica"
            src="../player/player.html"
            title="Player de M√∫sica"
            frameborder="0"
            allow="autoplay">
        </iframe>
    </div>

    <script src="../Scripts/sound-effects.js" defer></script>
    <script src="../Scripts/player-toggle.js" defer></script>
    <script src="../Scripts/status-bar.js" defer></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" defer></script>
    <script src="https://unpkg.com/@barba/core" defer></script>
    <script src="../Scripts/barba-init.js" defer></script>

    <script src="../Scripts/theme-toggle.js" defer></script>

</body>
</html>
