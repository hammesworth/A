<!DOCTYPE html>
<html lang="pt-br">
<head>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

    <link rel="icon" type="image/png" href="../Others/Icons/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../Others/Icons/favicon.svg" />
    <link rel="shortcut icon" href="../Others/Icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../Others/Icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="Microspace" />
    <link rel="manifest" href="../Others/Icons/site.webmanifest" />
    
    <link rel="stylesheet" href="../estilo.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Inter:wght@400;600;700;800&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <title>Guia C++: Exerc√≠cios de Fun√ß√µes e La√ßos</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

</head>

<body data-barba="wrapper">

        <button id="theme-toggle" aria-label="Alternar tema" title="Alternar tema">
        <span id="theme-icon">üåô</span>
        </button>

    <div data-barba="container" data-barba-namespace="Cpp-While-Exercicios" namespace="default-view">

<header>

    <h1>Exerc√≠cios de L√≥gica com C++ üß†</h1>
    <p>Implementando fun√ß√µes cl√°ssicas de matem√°tica e sequ√™ncias com la√ßos de repeti√ß√£o.</p>

    <nav>
        <p><a href="../index.html" class="nav-link">Inic√≠o üè°</a></p>
        <p><a href="../Hubs/ArquiteturaComp-Hub.html" class="nav-link"> Arquitetura ‚öôÔ∏è</a></p>
        <p><a href="../Hubs/Matematica-Hub.html" class="nav-link">Matem√°tica ‚úñÔ∏è</a></p>
        <p><a href="../Hubs/Cpp-Hub.html" class="nav-link">C++ üîß</a></p>
        <p><a href="../Hubs/InfoBasica-Hub.html" class="nav-link">Info B√°sica üñ•Ô∏è</a></p>
        <p><a href="../Hubs/DesignWeb-Hub.html" class="nav-link">Design Web üåê</a></p>
        <p><a href="../Hubs/Jogos-Hub.html" class="nav-link">Jogos üïπÔ∏è</a></p>
    </nav>
</header>

<main>

<div id="xml-intro">

    <section id="intro">
        <h2 class="subtitle">üéØ Resolvendo Problemas com Fun√ß√µes e La√ßos</h2>
        <p>A combina√ß√£o de fun√ß√µes para modularizar o c√≥digo e la√ßos de repeti√ß√£o para executar tarefas repetitivas √© a base da programa√ß√£o estruturada. Abaixo, voc√™ encontrar√° uma s√©rie de exerc√≠cios cl√°ssicos resolvidos em C++, demonstrando como implementar algoritmos matem√°ticos e sequenciais do zero.</p>
        <p>Cada exerc√≠cio apresenta a cria√ß√£o de uma ou mais fun√ß√µes espec√≠ficas e um programa principal (<code>main</code>) para testar sua funcionalidade, como solicitado.</p>
    </section>

    <section id="exercicios-propostos">
        <h2 class="subtitle">‚úèÔ∏è Exerc√≠cios Resolvidos</h2>

        <!-- Exerc√≠cio 1: Floor e Ceil -->
        <div class="exercise">
            <h4>Exerc√≠cio 1: Fun√ß√µes Floor e Ceil</h4>
            <p><strong>Problema:</strong> Supondo a inexist√™ncia da biblioteca <code>math.h</code>, implemente fun√ß√µes para calcular o piso (floor) e o teto (ceil) de um n√∫mero real. Crie um programa principal para test√°-las.</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include <iostream>
using namespace std;

int meu_floor(float num) {
    int resultado = 0;

    if (num >= 0) {
        while (resultado + 1 <= num) {
            resultado++;
        }
    } else {
        while (resultado - 1 > num) {
            resultado--;
        }
    }

    return resultado;
}

int meu_ceil(float num) {
    int resultado = 0;

    if (num >= 0) {
        while (resultado < num) {
            resultado++;
        }
    } else {
        while (resultado - 1 >= num) {
            resultado--;
        }
    }

    return resultado;
}

int main() {
    float teste1 = 5.8;
    float teste2 = -4.2;
    float teste3 = 7.0;

    cout << "Testando meu_floor:\n";
    cout << "floor(" << teste1 << ") = " << meu_floor(teste1) << "\n";
    cout << "floor(" << teste2 << ") = " << meu_floor(teste2) << "\n";
    cout << "floor(" << teste3 << ") = " << meu_floor(teste3) << "\n\n";

    cout << "Testando meu_ceil:\n";
    cout << "ceil(" << teste1 << ") = " << meu_ceil(teste1) << "\n";
    cout << "ceil(" << teste2 << ") = " << meu_ceil(teste2) << "\n";
    cout << "ceil(" << teste3 << ") = " << meu_ceil(teste3) << "\n";

    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o:</strong> as fun√ß√µes <code>meu_floor</code> e <code>meu_ceil</code> foram feitas do zero, sem usar bibliotecas como <code>math.h</code>. A ideia principal √© simular o comportamento matem√°tico do piso (floor) e teto (ceil) usando apenas <strong>la√ßos while</strong>.<br>
                <code>meu_floor</code>: A gente come√ßa com um int zerado (resultado = 0). Se o n√∫mero for positivo, a gente vai incrementando at√© chegar o mais perto poss√≠vel sem passar do n√∫mero. Se for negativo, vamos decrementando at√© passar do valor, e depois voltamos 1 passo (simulando o ‚Äúpiso‚Äù de n√∫meros negativos, como floor(-4.2) = -5).<br>
                <code>meu_ceil</code>: Mesma ideia, s√≥ que ao contr√°rio. Se o n√∫mero for positivo com casa decimal (tipo 5.8), subimos at√© passar dele e parar no primeiro n√∫mero inteiro maior ou igual. Para negativos, o teto √© mais "brando": ceil(-4.2) = -4, e n√£o -5.
</p>
        </div>

        <!-- Exerc√≠cio 2: Pot√™ncia -->
        <div class="exercise">
            <h4>Exerc√≠cio 2: Fun√ß√£o de Pot√™ncia</h4>
            <p><strong>Problema:</strong> Implemente uma fun√ß√£o para calcular a pot√™ncia entre dois n√∫meros inteiros quaisquer (base e expoente positivos ou negativos). Teste os casos 2¬≥, 2‚Åª¬≥, (-3)¬≤ e (-3)‚Åª¬≤.</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include <iostream>
using namespace std;

float potencia(int base, int expoente) {
    float resultado = 1.0;
    int contador = 0;

    int expoentePositivo = expoente >= 0 ? expoente : -expoente;

    while (contador < expoentePositivo) {
        resultado = resultado * base;
        contador++;
    }

    if (expoente < 0) {
        return 1.0 / resultado;
    }

    return resultado;
}

int main() {
    cout << "Testando potencia:\n";
    cout << "2^3 = " << potencia(2, 3) << "\n";
    cout << "2^-3 = " << potencia(2, -3) << "\n";
    cout << "(-3)^2 = " << potencia(-3, 2) << "\n";
    cout << "(-3)^-2 = " << potencia(-3, -2) << "\n";

    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o:</strong> Essa fun√ß√£o potencia calcula qualquer pot√™ncia base^expoente, mesmo se o expoente for negativo. E tudo isso s√≥ com <code>while</code>, sem operadores prontos. Como funciona: A gente pega o valor absoluto do expoente (pra evitar complica√ß√µes com negativos no la√ßo). Multiplicamos a base por ela mesma o n√∫mero de vezes indicado. Se o expoente for negativo no final, a gente inverte o resultado (1.0 / resultado), porque x‚Åª‚Åø = 1 / x‚Åø.<br>
<br>
Exemplo:<br>
<br>
2^3 ‚Üí resultado: 8<br>
2^-3 ‚Üí resultado: 1 / 8 = 0.125<br>
(-3)^2 ‚Üí resultado: 9<br>
(-3)^-2 ‚Üí resultado: 1 / 9 ‚âà 0.1111</p>
        </div>

        <!-- Exerc√≠cio 3: N√∫mero Primo -->
        <div class="exercise">
            <h4>Exerc√≠cio 3: Fun√ß√£o de N√∫mero Primo</h4>
            <p><strong>Problema:</strong> Escreva uma fun√ß√£o que retorne verdadeiro ou falso para o fato de um n√∫mero ser primo. Crie um programa principal para test√°-la.</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include <iostream>
using namespace std;

bool ehPrimo(int num) {
    if (num <= 1) {
        return false;
    }

    int divisor = 2;

    while (divisor <= num / 2) {
        if (num % divisor == 0) {
            return false;
        }
        divisor++;
    }

    return true;
}

int main() {
    cout << "Testando ehPrimo:\n";
    cout << "29 e primo? " << (ehPrimo(29) ? "Sim" : "Nao") << "\n";
    cout << "15 e primo? " << (ehPrimo(15) ? "Sim" : "Nao") << "\n";
    cout << "2 e primo? " << (ehPrimo(2) ? "Sim" : "Nao") << "\n";
    cout << "1 e primo? " << (ehPrimo(1) ? "Sim" : "Nao") << "\n";

    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o:</strong> A fun√ß√£o <code>ehPrimo</code> checa se um n√∫mero √© primo ‚Äî ou seja, se s√≥ √© divis√≠vel por 1 e por ele mesmo. <strong>O que ela faz:</strong> Se o n√∫mero for 1 ou menor, j√° descarta (n√£o √© primo). Depois, testa todos os divisores de 2 at√© metade do n√∫mero. Por qu√™ s√≥ at√© a metade? Porque n√£o tem como um n√∫mero ser dividido por algo maior que a sua metade e ainda dar inteiro. Se encontrar qualquer divisor no meio do caminho, j√° retorna false. Se passar por tudo e n√£o achar nenhum divisor, ent√£o √© primo!</p>
        </div>

        <!-- Exerc√≠cio 4: Fatorial -->
        <div class="exercise">
            <h4>Exerc√≠cio 4: Fun√ß√£o Fatorial</h4>
            <p><strong>Problema:</strong> Implemente uma fun√ß√£o para calcular o fatorial de um n√∫mero inteiro n√£o-negativo. Lembre-se que 0! = 1. Crie um programa principal para test√°-la.</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include <iostream>
using namespace std;

float fatorial(int n) {
    if (n < 0) {
        return 0; // Erro: fatorial negativo n√£o existe
    }

    float resultado = 1;
    int contador = n;

    while (contador > 1) {
        resultado = resultado * contador;
        contador--;
    }

    return resultado;
}

int main() {
    cout << "Testando fatorial:\n";
    cout << "5! = " << fatorial(5) << "\n";
    cout << "0! = " << fatorial(0) << "\n";
    cout << "10! = " << fatorial(10) << "\n";

    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o:</strong> A fun√ß√£o fatorial calcula o produto de todos os inteiros positivos at√© n. Ou seja:<br>
<br>
<code>n! = n √ó (n-1) √ó (n-2) √ó ... √ó 2 √ó 1</code><br>
<br>
<strong>Como ela funciona:</strong>
Se o n√∫mero for menor que 0, retorna 0 (fatorial negativo n√£o existe).
Se for 0, retorna 1 (por defini√ß√£o matem√°tica).
Se for positivo, o while come√ßa do n e vai multiplicando resultado at√© o contador chegar em 1.<br>
<br>
Exemplo:<br>
<br>
fatorial(5) ‚Üí 5 √ó 4 √ó 3 √ó 2 √ó 1 = 120<br>
fatorial(0) ‚Üí 1<br>
fatorial(10) ‚Üí 3628800</p>
        </div>
        
        <!-- Exerc√≠cio 5: Fibonacci -->
        <div class="exercise">
            <h4>Exerc√≠cio 5: Sequ√™ncia de Fibonacci</h4>
            <p><strong>Problema:</strong> A sequ√™ncia de Fibonacci come√ßa com 0 e 1, e cada termo subsequente √© a soma dos dois anteriores (0, 1, 1, 2, 3, 5, ...). Implemente uma fun√ß√£o para retornar o n-√©simo termo da sequ√™ncia.</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 0) return 0;
    if (n == 1) return 1;

    int anterior = 0;
    int atual = 1;
    int contador = 2;

    while (contador <= n) {
        int proximo = anterior + atual;
        anterior = atual;
        atual = proximo;
        contador++;
    }

    return atual;
}

int main() {
    cout << "Testando fibonacci:\n";
    cout << "Termo 5: " << fibonacci(5) << "\n";
    cout << "Termo 8: " << fibonacci(8) << "\n";
    cout << "Termo 1: " << fibonacci(1) << "\n";

    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o:</strong> A fun√ß√£o trata os casos base <code>n=0</code> e <code>n=1</code>. Para <code>n > 1</code>, inicializamos <code>anterior = 0</code> e <code>atual = 1</code>. O la√ßo <code>while</code> roda de 2 at√© <code>n</code>. Em cada itera√ß√£o, calculamos o pr√≥ximo termo somando os dois anteriores. Em seguida, atualizamos as vari√°veis: o <code>atual</code> vira o <code>anterior</code>, e o <code>proximo</code> calculado vira o novo <code>atual</code>. O la√ßo efetivamente "caminha" pela sequ√™ncia at√© atingir a posi√ß√£o <code>n</code>, retornando o valor contido em <code>atual</code>.</p>
        </div>
    </section>

</div>

</main>

<footer>

    <p>
    <a href="../Hubs/Cpp-Hub.html"><i class="fa-solid fa-circle-chevron-left"></i></a>
    <a href="../index.html"><i class="fa-solid fa-house-chimney"></i></a>
    <a href="#"><i class="fa-solid fa-circle-chevron-up"></i></a>
    </p>

    <p class="copyright"> ¬©Ô∏è 2025 - Lucas Willian</p>
    
</footer>

</div>

    <div id="player-wrapper" class="is-hidden">
        
        <iframe 
            id="meu-player-de-musica"
            src="../player/player.html"
            title="Player de M√∫sica"
            frameborder="0"
            allow="autoplay">
        </iframe>

    </div>

    <button id="toggle-player-btn" aria-label="Controlar Player">
    üéµ
    </button>

    <script src="../Scripts/sound-effects.js" defer></script>
    <script src="../Scripts/player-toggle.js" defer></script>
    <script src="../Scripts/status-bar.js" defer></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" defer></script>
    <script src="https://unpkg.com/@barba/core" defer></script>
    <script src="../Scripts/barba-init.js" defer></script>

    <script src="../Scripts/theme-toggle.js" defer></script>

</body>
</html>
