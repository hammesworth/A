<!DOCTYPE html>
<html lang="pt-br">
<head>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="../estilo.css">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Inter:wght@400;600;700;800&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <title>Guia de La√ßos e Vetores C++</title>
    
    <!-- NOVO: Biblioteca de √°udio Tone.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

</head>

<body data-barba="wrapper">

    <div class="search-container" style="margin-bottom: 2rem;"> 
        <input type="text" id="search-bar" placeholder="Pesquisar m√≥dulos ou se√ß√µes...">
        <div class="search-results-box" style="display: none;"></div>
        <span id="autocomplete-suggestion"></span>
        </div>

        <div data-barba="container" data-barba-namespace="Cpp-While" namespace="default-view">

<header>
    <h1>Guia Detalhado do La√ßo 'while' em C++ üõ†Ô∏è</h1>
    <p>Um mergulho profundo na estrutura de repeti√ß√£o mais fundamental para controle de fluxo.</p>

    <nav>
        <a href="/Design_Web_Hub.html" class="nav-link">Guias de Design Web</a>
            <a href="xml_git.html" class="nav-link">Guia de XML & Git</a>
            <a href="ArquiteturaHub.html" class="nav-link">Guias de Arquitetura Comp.</a>
            <a href="infobasic.html" class="nav-link">Guia de Info B√°sica</a>
            <a href="cpp.html" class="nav-link">Guia b√°sico de C++</a>
    </nav>
</header>

<main>

    <!-- Adicionada classe 'filterable-section' para a busca funcionar -->
        <section id="sintaxe" class="filterable-section">

<div id="xml-intro">

    <section id="intro">
      <h2 class="subtitle">üîÅ Introdu√ß√£o ao La√ßo While</h2>
      <p>O comando <code>while</code> (que se traduz como "enquanto") √© uma das estruturas de repeti√ß√£o mais essenciais na programa√ß√£o. Sua fun√ß√£o √© executar repetidamente um bloco de c√≥digo <strong>enquanto</strong> uma determinada condi√ß√£o permanecer verdadeira.</p>
      <p>A principal caracter√≠stica do <code>while</code> √© ser um <strong>la√ßo pr√©-condicional</strong>. Isso significa que a condi√ß√£o √© sempre testada <strong>antes</strong> de cada poss√≠vel execu√ß√£o do bloco. Se, na primeira verifica√ß√£o, a condi√ß√£o j√° for falsa, o bloco de c√≥digo interno nunca ser√° executado.</p>
      <p>Este comportamento o torna ideal para situa√ß√µes onde o n√∫mero de repeti√ß√µes √© indeterminado e depende de um evento externo, como uma entrada de usu√°rio, o fim de um arquivo ou a mudan√ßa de um estado no programa.</p>
    </section>

    <section id="sintaxe">
        <h2 class="subtitle">‚öôÔ∏è Sintaxe e Fluxo de Execu√ß√£o</h2>
        <p>A estrutura do <code>while</code> √© simples e direta. Ela consiste na palavra-chave <code>while</code>, seguida por uma condi√ß√£o entre par√™nteses e um bloco de c√≥digo delimitado por chaves <code>{}</code>.</p>
        <pre class="code">
while (condicao) {
    // Bloco de c√≥digo a ser repetido
    // enquanto a 'condicao' for verdadeira.
    // √â crucial que algo aqui dentro possa, eventualmente,
    // tornar a 'condicao' falsa.
}
        </pre>
        <p>O fluxo de execu√ß√£o ocorre da seguinte forma:</p>
        <ul>
            <li><strong>Teste da Condi√ß√£o:</strong> O programa avalia a express√£o booleana dentro dos par√™nteses.</li>
            <li><strong>Execu√ß√£o do Bloco:</strong> Se a condi√ß√£o for <code>true</code>, o c√≥digo dentro das chaves √© executado linha por linha.</li>
            <li><strong>Retorno ao Teste:</strong> Ap√≥s a √∫ltima linha do bloco ser executada, o controle do programa volta para o passo 1, e a condi√ß√£o √© testada novamente.</li>
            <li><strong>T√©rmino do La√ßo:</strong> Se a condi√ß√£o for avaliada como <code>false</code>, o bloco de c√≥digo √© ignorado e o programa continua sua execu√ß√£o na primeira instru√ß√£o que estiver ap√≥s a chave de fechamento <code>}</code> do <code>while</code>.</li>
        </ul>

        <p>Veja um exemplo b√°sico que ilustra esse fluxo:</p>
        <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    int contador = 1; // 1. Inicializa√ß√£o da vari√°vel de controle

    // 2. Teste da condi√ß√£o (1 <= 5 √© verdadeiro)
    while (contador <= 5) {
        // 3. Execu√ß√£o do bloco
        cout << "O contador vale: " << contador << "\n";

        // 4. Modifica√ß√£o da vari√°vel de controle
        contador++; // Equivalente a contador = contador + 1;
    } // 5. Fim do bloco, retorna ao passo 2 para um novo teste

    cout << "Fim do laco." << "\n"; // 6. Executado quando a condi√ß√£o se torna falsa
    return 0;
}
        </pre>
        <p><strong>Sa√≠da do c√≥digo:</strong><br>
        O contador vale: 1<br>
        O contador vale: 2<br>
        O contador vale: 3<br>
        O contador vale: 4<br>
        O contador vale: 5<br>
        Fim do la√ßo.
        </p>
    </section>

    <section id="infinito">
        <h2 class="subtitle">‚ö†Ô∏è O Perigo do Loop Infinito</h2>
        <p>Um dos erros mais comuns ao usar o <code>while</code> √© criar um <strong>loop infinito</strong>. Isso acontece quando a condi√ß√£o do la√ßo nunca se torna falsa. Consequentemente, o programa fica preso, executando o mesmo bloco de c√≥digo indefinidamente, o que geralmente trava a aplica√ß√£o e pode consumir 100% de um n√∫cleo de CPU.</p>
        <p>A causa √© quase sempre a mesma: a vari√°vel ou o estado que controla a condi√ß√£o <strong>nunca √© alterado</strong> dentro do la√ßo de uma forma que o leve ao t√©rmino.</p>
        <pre class="code">
#include &lt;iostream&gt;
using namespace std;

// ATENCAO: Este c√≥digo cria um loop infinito.
// Nao execute a menos que saiba como parar o programa.
int main() {
    int i = 0;
    while (i < 10) {
        cout << "Estou preso no loop!" << "\n";
        // O erro est√° aqui: 'i' nunca √© incrementado.
        // A condi√ß√£o 'i < 10' ser√° eternamente verdadeira.
    }
    return 0; // Esta linha nunca ser√° alcan√ßada.
}
        </pre>
        <p>Para evitar isso, sempre garanta que haja uma "rota de fuga", ou seja, que a l√≥gica dentro do la√ßo eventualmente far√° com que a condi√ß√£o se torne <code>false</code>.</p>
    </section>

    <section id="aplicacoes">
        <h2 class="subtitle">üí° Aplica√ß√µes Pr√°ticas do While</h2>
        <p>O <code>while</code> brilha em cen√°rios onde a repeti√ß√£o n√£o √© contada, mas condicional.</p>
        
        <h3>1. Valida√ß√£o de Entrada de Usu√°rio</h3>
        <p>Um uso cl√°ssico √© for√ßar o usu√°rio a digitar um dado v√°lido.</p>
        <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    int idade;
    cout << "Por favor, digite sua idade: ";
    cin >> idade;

    // Enquanto a idade for inv√°lida (menor que 0 ou maior que 120)
    while (idade < 0 || idade > 120) {
        cout << "Idade invalida! Por favor, digite um valor entre 0 e 120: ";
        cin >> idade; // Pede a entrada novamente
    }

    cout << "Obrigado! Sua idade e " << idade << " anos." << "\n";
    return 0;
}
        </pre>

        <h3>2. Menu Interativo</h3>
        <p>Manter um menu de op√ß√µes ativo at√© que o usu√°rio escolha sair.</p>
        <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    int escolha = 0;

    // O loop continua enquanto a escolha for diferente de 4 (op√ß√£o de sair)
    while (escolha != 4) {
        cout << "\n--- MENU ---\n";
        cout << "1. Jogar\n";
        cout << "2. Ver pontuacoes\n";
        cout << "3. Ajuda\n";
        cout << "4. Sair\n";
        cout << "Escolha uma opcao: ";
        cin >> escolha;

        if (escolha == 1) {
            cout << "Iniciando o jogo...\n";
        } else if (escolha == 2) {
            cout << "Exibindo pontuacoes...\n";
        } else if (escolha == 3) {
            cout << "Mostrando a ajuda...\n";
        }
    }

    cout << "Obrigado por jogar. Ate mais!\n";
    return 0;
}
        </pre>
    </section>

    <section id="controle">
        <h2 class="subtitle">Controle Fino: `break` e `continue`</h2>
        <p>√Äs vezes, √© necess√°rio alterar o fluxo padr√£o de um la√ßo <code>while</code>. Para isso, existem duas palavras-chave importantes:</p>
        <ul>
            <li><code>break</code>: Encerra o la√ßo <strong>imediatamente</strong>, independentemente do estado da condi√ß√£o. A execu√ß√£o salta para a primeira linha de c√≥digo ap√≥s o la√ßo.</li>
            <li><code>continue</code>: Pula o restante do c√≥digo da itera√ß√£o atual e volta <strong>imediatamente</strong> para o teste da condi√ß√£o do <code>while</code>, iniciando a pr√≥xima itera√ß√£o se a condi√ß√£o for verdadeira.</li>
        </ul>

        <h3>Exemplo com `break`</h3>
        <p>O la√ßo abaixo foi projetado para rodar 1000 vezes, mas o <code>break</code> o interrompe se um n√∫mero espec√≠fico for encontrado.</p>
        <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    int numero = 0;
    while (numero < 1000) {
        cout << numero << " ";
        if (numero == 7) {
            cout << "\nEncontrei o 7! Saindo do laco...";
            break; // Termina o 'while' aqui mesmo.
        }
        numero++;
    }
    cout << "\nFora do laco.\n";
    return 0;
}
        </pre>
        <p><strong>Sa√≠da:</strong> 0 1 2 3 4 5 6 7 <br>Encontrei o 7! Saindo do laco...<br>Fora do laco.</p>

        <h3>Exemplo com `continue`</h3>
        <p>Este c√≥digo imprime apenas os n√∫meros √≠mpares. Quando `i` √© par, <code>continue</code> pula a instru√ß√£o <code>cout</code>.</p>
        <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    int i = 0;
    while (i < 10) {
        i++;
        if (i % 2 == 0) { // Se 'i' for par...
            continue; // ...pule para a pr√≥xima itera√ß√£o, ignorando o cout.
        }
        cout << i << " "; // Esta linha s√≥ executa para n√∫meros √≠mpares.
    }
    cout << "\n";
    return 0;
}
        </pre>
        <p><strong>Sa√≠da:</strong> 1 3 5 7 9</p>
    </section>

    <section id="exercicios">
        <h2 class="subtitle">‚úèÔ∏è Exerc√≠cios Pr√°ticos</h2>
        <p>A melhor forma de aprender √© praticando. Tente resolver os problemas abaixo antes de olhar a resposta!</p>

        <div class="exercise">
            <h4>Exerc√≠cio 1: Contagem Regressiva</h4>
            <p><strong>Problema:</strong> Escreva um programa que pe√ßa ao usu√°rio um n√∫mero inteiro positivo e, em seguida, use um la√ßo <code>while</code> para imprimir uma contagem regressiva a partir desse n√∫mero at√© 1, finalizando com a mensagem "Decolar!".</p>
            <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    int contador;
    cout << "Digite um numero para a contagem regressiva: ";
    cin >> contador;

    while (contador > 0) {
        cout << contador << "...\n";
        contador--; // Decrementa o contador a cada itera√ß√£o
    }

    cout << "Decolar!\n";
    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o da Resposta:</strong> O la√ßo <code>while</code> continua executando enquanto a vari√°vel <code>contador</code> for maior que zero. A cada passo, o valor atual do contador √© impresso e, em seguida, ele √© decrementado (<code>contador--</code>). Quando o contador chega a 0, a condi√ß√£o <code>contador > 0</code> se torna falsa, o la√ßo termina, e a mensagem "Decolar!" √© impressa.</p>
        </div>

        <div class="exercise">
            <h4>Exerc√≠cio 2: Adivinhe o N√∫mero</h4>
            <p><strong>Problema:</strong> Crie um jogo simples onde o programa "pensa" em um n√∫mero secreto (ex: 42). Use um la√ßo <code>while</code> para pedir repetidamente que o usu√°rio adivinhe o n√∫mero. O la√ßo deve continuar at√© que o usu√°rio acerte. A cada tentativa, informe se o palpite foi muito alto, muito baixo ou correto.</p>
             <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    int numeroSecreto = 42;
    int palpite = 0;

    cout << "Adivinhe o numero secreto (entre 1 e 100)!\n";

    while (palpite != numeroSecreto) {
        cout << "Qual o seu palpite? ";
        cin >> palpite;

        if (palpite < numeroSecreto) {
            cout << "Muito baixo! Tente de novo.\n";
        } else if (palpite > numeroSecreto) {
            cout << "Muito alto! Tente de novo.\n";
        }
    }

    cout << "Parabens! Voce acertou o numero secreto!\n";
    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o da Resposta:</strong> O la√ßo √© controlado pela condi√ß√£o <code>palpite != numeroSecreto</code>. Enquanto o palpite do usu√°rio for diferente do n√∫mero secreto, o la√ßo continua. Dentro dele, uma estrutura <code>if-else if</code> verifica se o palpite √© menor ou maior que o alvo, dando uma dica ao usu√°rio. O la√ßo s√≥ termina quando o usu√°rio digita o n√∫mero correto, momento em que a condi√ß√£o se torna falsa e a mensagem de parab√©ns √© exibida.</p>
        </div>

        <div class="exercise">
            <h4>Exerc√≠cio 3: Soma de D√≠gitos</h4>
            <p><strong>Problema:</strong> Pe√ßa ao usu√°rio um n√∫mero inteiro. Use um la√ßo <code>while</code> para calcular a soma de todos os seus d√≠gitos. Por exemplo, se o usu√°rio digitar <code>123</code>, o programa deve imprimir <code>6</code> (pois 1 + 2 + 3 = 6).</p>
             <p><strong>Solu√ß√£o:</strong></p>
            <pre class="code">
#include &lt;iostream&gt;
using namespace std;

int main() {
    int numero, soma = 0;
    cout << "Digite um numero inteiro para somar seus digitos: ";
    cin >> numero;

    int numeroOriginal = numero; // Guarda o n√∫mero original para exibir no final

    while (numero > 0) {
        soma += numero % 10; // Adiciona o √∫ltimo d√≠gito √† soma
        numero /= 10;        // Remove o √∫ltimo d√≠gito do n√∫mero
    }

    cout << "A soma dos digitos de " << numeroOriginal << " e: " << soma << "\n";
    return 0;
}
            </pre>
            <p><strong>Explica√ß√£o da Resposta:</strong> Este √© um uso inteligente da matem√°tica. O operador m√≥dulo <code>% 10</code> retorna o √∫ltimo d√≠gito de um n√∫mero (ex: <code>123 % 10</code> √© <code>3</code>). A divis√£o inteira <code>/ 10</code> remove o √∫ltimo d√≠gito (ex: <code>123 / 10</code> √© <code>12</code>). O la√ßo <code>while</code> repete esse processo, somando o √∫ltimo d√≠gito e depois o removendo, at√© que o n√∫mero se torne 0. Quando isso acontece, todos os d√≠gitos foram somados.</p>
        </div>
    </section>

</div>

</section>

</main>

</div>

<footer>
    
    <iframe 
    id="meu-player-de-musica"  src="../player/player.html"
    title="Player de M√∫sica"
    frameborder="0"
    allow="autoplay"
    style="position: fixed; bottom: 0; left: 0; width: 100%; height: 80px; z-index: 1000; border: none;">
    </iframe>

<div style="height: 80px;"></div>

    <p style="text-align: center; margin-top: 40px;">üíª Teste os exemplos em um compilador online como o GDB para praticar.</p>
    <p>&copy; 2025 - Lucas Willian</p>
</footer>

    <!-- Scripts JS -->
    <script src="../Scripts/search.js" defer></script>
    <!-- NOVO: Script para efeitos sonoros  -->
    <script src="../Scripts/sound-effects.js" defer></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" defer></script>
    <script src="https://unpkg.com/@barba/core" defer></script>
    <script src="../Scripts/barba-init.js" defer></script>

</body>
</html>
