<!DOCTYPE html>
<html lang="pt-br">
<head>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="stylesheet" href="../estilo.css">

    <link rel="icon" type="image/png" href="../Others/Icons/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="../Others/Icons/favicon.svg" />
    <link rel="shortcut icon" href="../Others/Icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="../Others/Icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="Microspace" />
    <link rel="manifest" href="../Others/Icons/site.webmanifest" />
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://css.googleapis.com/css2?family=Fira+Code&family=Inter:wght@400;600;700;800&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <title>Opera√ß√µes com Bases e Aritm√©tica Bin√°ria</title>
 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

</head>

<body data-barba="wrapper">

    <button id="theme-toggle" aria-label="Alternar tema" title="Alternar tema">
        <span id="theme-icon">üåô</span>
    </button>

    <div data-barba="container" data-barba-namespace="Arquitetura-Operacoes" namespace="default-view">

<header>

    <h1>Opera√ß√µes com Bases e Aritm√©tica Bin√°ria ‚ûï</h1>
    <p>O guia definitivo sobre como os computadores calculam</p>

    <nav>

        <p><a href="../index.html" class="nav-link">Inic√≠o üè°</a></p>
        <p><a href="../Hubs/ArquiteturaComp-Hub.html" class="nav-link"> Arquitetura ‚öôÔ∏è</a></p>
        <p><a href="../Hubs/Matematica-Hub.html" class="nav-link">Matem√°tica ‚úñÔ∏è</a></p>
        <p><a href="../Hubs/Cpp-Hub.html" class="nav-link">C++ üîß</a></p>
        <p><a href="../Hubs/InfoBasica-Hub.html" class="nav-link">Info B√°sica üñ•Ô∏è</a></p>
        <p><a href="../Hubs/DesignWeb-Hub.html" class="nav-link">Design Web üåê</a></p>
        <p><a href="../Hubs/Jogos-Hub.html" class="nav-link">Jogos üïπÔ∏è</a></p>

    </nav>

</header>

<main>
<div id="binary-operations-intro">

    <section>
      <h2 class="subtitle">üßÆ Aritm√©tica Bin√°ria: A Matem√°tica dos Transistores</h2>
      <p>No n√≠vel mais fundamental, um computador √© uma m√°quina de calcular incrivelmente r√°pida. Mas como ele realiza opera√ß√µes matem√°ticas complexas usando apenas dois s√≠mbolos, 0 e 1? A resposta est√° na aritm√©tica bin√°ria, um conjunto de regras que adapta as opera√ß√µes que conhecemos (soma, subtra√ß√£o) para o sistema de base 2. Dominar essa aritm√©tica √© entender o "pensamento" do processador.</p>
    </section>

    <section>
    
    <h2 class="subtitle">üîå Bits, Portas L√≥gicas e √Ålgebra Booleana</h2>
    <p>No cora√ß√£o da computa√ß√£o digital, as opera√ß√µes bin√°rias s√£o implementadas fisicamente por <strong>portas l√≥gicas</strong>, que nada mais s√£o do que circuitos eletr√¥nicos capazes de realizar opera√ß√µes da <strong>√°lgebra booleana</strong>.</p>
    <p>A √Ålgebra Booleana √© uma matem√°tica bin√°ria criada por George Boole no s√©culo XIX. Ela descreve como vari√°veis que s√≥ assumem dois valores (<code>0</code> ou <code>1</code>) podem se combinar por meio de operadores como:</p>
  
    <ul>
    <li><code>AND</code> (E): S√≥ retorna <code>1</code> se ambos forem <code>1</code>.</li>
    <li><code>OR</code> (OU): Retorna <code>1</code> se pelo menos um for <code>1</code>.</li>
    <li><code>NOT</code> (N√ÉO): Inverte o valor. <code>NOT 1 = 0</code>, <code>NOT 0 = 1</code>.</li>
    </ul>

    <p>Outras opera√ß√µes √∫teis como <code>XOR</code> (ou exclusivo), <code>NAND</code> (n√£o E) e <code>NOR</code> (n√£o OU) derivam dessas.</p>
    
    </section>

</div>

    <section>
        <h2 class="subtitle">‚ûï Soma Bin√°ria: O "Vai-Um" Digital</h2>
        <p>A soma bin√°ria segue uma l√≥gica muito parecida com a soma decimal, mas √© ainda mais simples, pois s√≥ temos quatro possibilidades b√°sicas para somar dois bits:</p>
        <ul>
            <li><code>0 + 0 = 0</code></li>
            <li><code>0 + 1 = 1</code></li>
            <li><code>1 + 0 = 1</code></li>
            <li><code>1 + 1 = 0</code> e <strong>"vai-um"</strong> (carry) para a pr√≥xima coluna √† esquerda. Este √© o ponto-chave. Em decimal, 1+1=2, que em bin√°rio √© escrito como <code>10</code>.</li>
        </ul>

        <p><strong>Exemplo: Somar 1011 (11) e 0110 (6)</strong></p>
        <pre class="code">
  1 1 1   <- Bits de "vai-um" (carry)
  1 0 1 1   (N√∫mero A)
+ 0 1 1 0   (N√∫mero B)
---------
1 0 0 0 1   (Resultado)

// An√°lise passo a passo, da direita para a esquerda:
// Coluna 0 (LSB): 1 + 0 = 1.
// Coluna 1: 1 + 1 = 0, vai-um para a coluna 2.
// Coluna 2: 1 (carry) + 0 + 1 = 0, vai-um para a coluna 3.
// Coluna 3: 1 (carry) + 1 + 0 = 0, vai-um para a coluna 4.
// Coluna 4 (MSB): O √∫ltimo carry se torna o bit mais significativo.

// Verifica√ß√£o: 11 + 6 = 17. O resultado bin√°rio 10001 √© 16 + 1 = 17. Correto!
        </pre>
    </section>

    <section>
        <h2 class="subtitle">‚ûñ Subtra√ß√£o Bin√°ria e o Complemento de 2</h2>
        <p>A subtra√ß√£o direta em bin√°rio existe, mas envolve uma l√≥gica de "emprestar" (borrow) que torna o design de circuitos (hardware) mais complexo. Para otimizar isso, os computadores usam um truque genial: eles transformam toda subtra√ß√£o em uma soma usando uma t√©cnica chamada <strong>Complemento de 2</strong>.</p>
        
        <h3 class="sub-subtitle">O Que √© o Complemento de 2?</h3>
        <p>√â um m√©todo para representar n√∫meros negativos em bin√°rio. Fazer <code>A - B</code> √© o mesmo que fazer <code>A + (-B)</code>. O Complemento de 2 √© a forma como encontramos o valor de <code>-B</code> em bin√°rio. O processo tem dois passos simples:</p>
        <ol>
            <li><strong>Passo 1: Complemento de 1</strong> - Inverta todos os bits do n√∫mero (troque 0 por 1 e 1 por 0).</li>
            <li><strong>Passo 2: Adicionar 1</strong> - Some 1 ao resultado do passo anterior.</li>
        </ol>

        <p><strong>Exemplo: Achar o Complemento de 2 de 0110 (6) para 8 bits</strong></p>
        <pre class="code">
// N√∫mero original (6) em 8 bits:
0000 0110

// Passo 1: Complemento de 1 (inverter tudo).
1111 1001

// Passo 2: Adicionar 1.
  1111 1001
+         1
-----------
  1111 1010  <- Este √© o bin√°rio para -6 em Complemento de 2

// O bit mais √† esquerda (MSB) ser 1 indica que o n√∫mero √© negativo.
        </pre>

        <h3 class="sub-subtitle">Realizando a Subtra√ß√£o com Complemento de 2</h3>
        <p>Agora, para subtrair, somamos o primeiro n√∫mero com o complemento de 2 do segundo. O "vai-um" (carry) final que sair da opera√ß√£o √© simplesmente descartado.</p>

        <p><strong>Exemplo: Calcular 1001 (9) - 0101 (5)</strong></p>
        <pre class="code">
// O problema √© 9 - 5. Vamos transform√°-lo em 9 + (-5).
// 1. Achar o complemento de 2 de 0101 (5).
N√∫mero original (5):   0101
Complemento de 1:      1010
Soma 1:              +    1
Complemento de 2 (-5): 1011

// 2. Somar 1001 (9) com 1011 (-5).
  1 0 0 1
+ 1 0 1 1
-----------
1 0 1 0 0  <- Resultado da soma

// 3. Descartar o carry final (o '1' mais √† esquerda).
Resultado: 0100

// Verifica√ß√£o: O resultado bin√°rio 0100 √© 4. 9 - 5 = 4. Correto!
        </pre>
    </section>
    
    <section>
        <h2 class="subtitle">‚ö†Ô∏è Overflow: Quando o Pote Transborda</h2>
        <p>Computadores trabalham com um n√∫mero fixo de bits para representar n√∫meros (ex: 8, 16, 32, 64 bits). <strong>Overflow</strong> (ou estouro) √© um erro que ocorre quando o resultado de uma opera√ß√£o aritm√©tica √© maior do que o que pode ser representado com o n√∫mero de bits dispon√≠veis. √â como tentar colocar 10 litros de √°gua em um balde de 5 litros - a √°gua vai transbordar.</p>
        <p>Em sistemas que usam complemento de 2, o bit mais √† esquerda (MSB) √© o <strong>bit de sinal</strong> (0 para positivo, 1 para negativo). O overflow √© particularmente perigoso aqui, pois pode levar a resultados absurdos:</p>
        <ul>
            <li>Somar dois n√∫meros positivos grandes e o resultado ser... negativo.</li>
            <li>Somar dois n√∫meros negativos grandes e o resultado ser... positivo.</li>
        </ul>

        <p><strong>Exemplo de Overflow (em 8 bits): Somar 100 e 50</strong></p>
        <pre class="code">
// Com 8 bits, o maior n√∫mero positivo √© 127 (0111 1111). 100+50 = 150, que n√£o cabe.
// 100 em decimal = 0110 0100
//  50 em decimal = 0011 0010

  0110 0100  (100)
+ 0011 0010  (50)
-----------
  1001 0110  (Resultado)

// An√°lise do resultado:
// O resultado √© 1001 0110. O bit de sinal (MSB) √© 1.
// O computador interpreta isso como um n√∫mero negativo! (-106 em complemento de 2).
// Ocorreu um overflow. Somamos dois positivos e obtivemos um negativo.

// Como detectar o Overflow?
// O "vai-um" para a coluna do bit de sinal foi 1, mas o "vai-um" para fora dela foi 0.
// Se o carry-in e o carry-out do bit de sinal s√£o diferentes, houve overflow.
        </pre>
    </section>

<section>
  <h2 class="subtitle">üìê Propriedades Fundamentais da √Ålgebra Booleana</h2>
  <p>Assim como na √°lgebra comum, a booleana possui um conjunto de leis que ajudam a simplificar e manipular express√µes. Aqui v√£o as principais (h√° um <a href="arquitetura_de_reducao.html">guia</a> apenas sobre isso, ent√£o esse ser√° apenas um resumo):</p>
  <ul>
    <li><strong>Comutativa:</strong> <code>A + B = B + A</code> e <code>A ¬∑ B = B ¬∑ A</code></li>
    <li><strong>Associativa:</strong> <code>A + (B + C) = (A + B) + C</code></li>
    <li><strong>Distributiva:</strong> <code>A ¬∑ (B + C) = A¬∑B + A¬∑C</code></li>
    <li><strong>Identidade:</strong> <code>A + 0 = A</code> e <code>A ¬∑ 1 = A</code></li>
    <li><strong>Dom√≠nio:</strong> <code>A + 1 = 1</code> e <code>A ¬∑ 0 = 0</code></li>
    <li><strong>Complemento:</strong> <code>A + A' = 1</code> e <code>A ¬∑ A' = 0</code></li>
    <li><strong>Dupla Nega√ß√£o:</strong> <code>(A')' = A</code></li>
    <li><strong>Absor√ß√£o:</strong> <code>A + A¬∑B = A</code> e <code>A ¬∑ (A + B) = A</code></li>
    <li><strong>Idempot√™ncia:</strong> <code>A + A = A</code> e <code>A ¬∑ A = A</code></li>
    <li><strong>De Morgan:</strong> <code>(A¬∑B)' = A' + B'</code> e <code>(A + B)' = A'¬∑B'</code></li>
  </ul>
  <p>Essas regras s√£o ferramentas poderosas na simplifica√ß√£o de circuitos digitais.</p>
</section>


    <section>
        <h2 class="subtitle">üîÑ Opera√ß√µes Entre Bases Diferentes (Aprofundado)</h2>
        <p>Trabalhar com arquitetura de computadores exige fluidez na convers√£o entre bases. Entender o "porqu√™" por tr√°s dos m√©todos √© crucial.</p>

        <h3 class="sub-subtitle">1. Qualquer Base para Decimal (Base 10)</h3>
        <p><strong>M√©todo: Expans√£o Polinomial.</strong> Este m√©todo funciona porque todo sistema num√©rico posicional √© uma soma de pot√™ncias da sua base. Cada d√≠gito √© um coeficiente que multiplica uma pot√™ncia da base, determinada por sua posi√ß√£o.</p>
        <p><em>Exemplo (Hexadecimal para Decimal):</em> Converter <strong>1A3</strong> para decimal.</p>
        <pre class="code">
// Posi√ß√µes:    2  1  0
// D√≠gitos:     1  A  3
// Valor: (1 * 16¬≤) + (A * 16¬π) + (3 * 16‚Å∞)
// Lembre-se que A = 10.
-> (1 * 256) + (10 * 16) + (3 * 1)
-> 256 + 160 + 3 = 419 (Decimal)
        </pre>
        
        <h3 class="sub-subtitle">2. Decimal (Base 10) para Qualquer Base</h3>
        <p><strong>M√©todo: Divis√µes Sucessivas.</strong> Este m√©todo funciona como uma "engenharia reversa" da expans√£o. Cada divis√£o pela base "isola" o coeficiente da menor pot√™ncia (o resto). O quociente restante √© o n√∫mero sem esse √∫ltimo d√≠gito. Repetimos o processo at√© n√£o sobrar mais nada. O primeiro resto √© o d√≠gito menos significativo (LSB), e o √∫ltimo resto √© o mais significativo (MSB), por isso lemos de baixo para cima.</p>
        <p><em>Exemplo (Decimal para Hexadecimal):</em> Converter <strong>419</strong> para hexadecimal.</p>
        <pre class="code">
419 √∑ 16 = 26, Resto: 3 (D√≠gito menos significativo)
26  √∑ 16 = 1,  Resto: 10 (que √© 'A' em hexadecimal)
1   √∑ 16 = 0,  Resto: 1 (D√≠gito mais significativo)

// Lendo os restos de baixo para cima: 1A3.
// Ent√£o, 419 (decimal) = 1A3 (hexadecimal).
        </pre>

        <h3 class="sub-subtitle">3. Convers√µes R√°pidas: O Poder do Agrupamento</h3>
        <p>A convers√£o entre Bin√°rio, Octal e Hexadecimal √© muito mais simples porque suas bases s√£o pot√™ncias de 2 (8 = 2¬≥, 16 = 2‚Å¥). Isso cria uma rela√ß√£o direta e previs√≠vel: <strong>cada d√≠gito hexadecimal corresponde a um grupo de 4 bits, e cada d√≠gito octal corresponde a um grupo de 3 bits.</strong></p>
        
        <p><strong>Tabela de Consulta R√°pida: Bin√°rio <-> Hexadecimal</strong></p>
        <pre class="code">
0000=0  0100=4  1000=8  1100=C (12)
0001=1  0101=5  1001=9  1101=D (13)
0010=2  0110=6  1010=A (10) 1110=E (14)
0011=3  0111=7  1011=B (11) 1111=F (15)
        </pre>

        <p><em>Exemplo (Bin√°rio para Hexadecimal):</em> Converter <strong>1101101100</strong>.</p>
        <pre class="code">
// 1. Agrupar em blocos de 4. Complete com zeros √† esquerda se necess√°rio.
Bin√°rio: 0011 0110 1100

// 2. Converter cada bloco usando a tabela.
0011 -> 3
0110 -> 6
1100 -> C

// Resultado: 36C (Hexadecimal)
        </pre>
        <p><em>Exemplo (Hexadecimal para Bin√°rio):</em> Converter <strong>E5B</strong>.</p>
        <pre class="code">
// 1. Pegue cada d√≠gito hexadecimal.
E   |   5   |   B

// 2. Converta cada um para seu grupo de 4 bits.
1110 | 0101 | 1011

// 3. Junte tudo.
Resultado: 111001011011 (Bin√°rio)
        </pre>
    </section>

<section>
  <h2 class="subtitle">üéÆ Complete a Tabela-Verdade</h2>
  <p>Complete os campos da coluna "Sa√≠da" com <code>0</code> ou <code>1</code>, com base na express√£o <code>(A ¬∑ B) + C</code>.</p>

  <div id="truth-table-game">
    <table>
      <thead>
        <tr>
          <th>A</th>
          <th>B</th>
          <th>C</th>
          <th>Sa√≠da</th>
        </tr>
      </thead>
      <tbody id="game-rows">
        <!-- As linhas ser√£o geradas via JS -->
      </tbody>
    </table>

    <button id="verificar-btn">Verificar Resultado ‚úÖ</button>
    <p id="feedback" style="margin-top: 10px;"></p>
  </div>
</section>

</main>

<footer>

    <p>
    <a href="../Hubs/ArquiteturaComp-Hub.html"><i class="fa-solid fa-circle-chevron-left"></i></a>
    <a href="../index.html"><i class="fa-solid fa-house-chimney"></i></a>
    <a href="#"><i class="fa-solid fa-circle-chevron-up"></i></a>
    </p>

    <p class="copyright"> ¬©Ô∏è 2025 - Lucas Willian</p>
    
</footer>

</div>

    <div id="player-wrapper" class="is-hidden">

    <iframe 
        id="meu-player-de-musica"
        src="../player/player.html"
        title="Player de M√∫sica"
        frameborder="0"
        allow="autoplay">
    </iframe>

    </div>

    <button id="toggle-player-btn" aria-label="Controlar Player">
    üéµ
    </button>

    <!-- Mantendo os scripts originais para compatibilidade -->
    <script src="../Scripts/sound-effects.js" defer></script>
    <script src="../Scripts/player-toggle.js" defer></script>
    <script src="../Scripts/status-bar.js" defer></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js" defer></script>
    <script src="https://unpkg.com/@barba/core" defer></script>
    <script src="../Scripts/barba-init.js" defer></script>

    <script src="../Scripts/theme-toggle.js" defer></script>

</body>
</html>
